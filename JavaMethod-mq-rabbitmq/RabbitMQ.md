# rabbitMQ 应用
## 添加注解
## 配置类
    com.example.rabbitmq.config.RabbitMQConfig
    生产者要获取注入的配置类 然后操作

## rabbitMQ 消息队列模式
    简单模式（Simple/Work Queues）：这是最基础的模式，生产者发送消息到队列中，消费者从队列中接收并处理消息。适用于任务分发场景，但不涉及复杂的路由。
    发布/订阅模式（Publish/Subscribe）：在此模式下，消息被广播给所有监听的消费者。每个消费者都会收到一份消息的副本。这通常通过交换机（Exchange）和绑定（Binding）来实现，其中消息先发送到交换机，然后根据绑定规则转发给相应的队列。
    路由模式（Routing）：此模式允许根据特定的路由键（routing key）将消息定向发送到感兴趣的消费者。生产者发送消息到交换机时指定一个路由键，而消费者则根据自身的绑定信息选择性地接收这些消息。
    主题模式（Topics）：是路由模式的一种更灵活的形式。它允许使用通配符来匹配消息的路由键，从而实现更加细粒度的消息过滤和分发。
    头部模式（Headers）：不同于基于路由键的路由机制，头部模式利用消息头中的属性进行更复杂的逻辑判断来决定消息的流向。
    RPC模式（Remote Procedure Call）：虽然不是RabbitMQ原生提供的模式之一，但可以通过RabbitMQ实现远程过程调用。客户端发送请求消息至服务器，并等待服务器端处理后返回响应消息。

## 交换机类型
RabbitMQ支持多种类型的交换机，每种类型决定了消息如何从生产者路由到一个或多个队列。以下是RabbitMQ中常见的交换机类型及其特点：

Direct Exchange（直接交换机）
特点：消息会路由到其绑定键（Binding Key）与消息的路由键（Routing Key）完全匹配的队列。
使用场景：当需要基于精确匹配的路由键将消息发送到特定队列时使用。
Fanout Exchange（扇出交换机）
特点：忽略路由键，将消息广播给所有绑定到该交换机的队列。
使用场景：适用于广播消息给所有监听的消费者，比如日志记录系统。
Topic Exchange（主题交换机）
特点：允许使用通配符进行模式匹配路由消息。*匹配一个单词，#匹配零个或多个单词。
使用场景：当需要更灵活的消息路由机制，例如根据多个条件或者部分匹配的路由键分发消息时。
Headers Exchange（头信息交换机）
特点：不同于使用路由键，它使用消息头属性进行匹配。可以设置多个属性，并且可以指定这些属性是否必须全部满足或是任意一个满足即可。
使用场景：适用于需要复杂、非字符串的路由逻辑的情况。
Consistent Hash Exchange（一致性哈希交换机）
特点：这是一种插件提供的交换机类型，通过哈希算法来决定消息路由至哪个队列。即使在添加或移除队列的情况下也能保持消息分布的一致性。
使用场景：适合于负载均衡和高可用性的场景，确保相同哈希值的消息总是被路由到相同的队列上。
您提到的例子中使用的fanout交换机属于扇出类型，它会将接收到的所有消息广播给所有绑定到它的队列，而不考虑任何路由键。
这种类型的交换机非常适合广播通知或者日志收集等场景，在这些场景下，所有的消费者都会接收到同样的消息。
如果您的应用场景需要不同的消息路由策略，可以根据需求选择上述其他类型的交换机。

# 消息确认机制
在讨论RabbitMQ中的发布/订阅模式（Pub/Sub）以及消息确认机制时，理解不同类型的交换机和队列如何工作是非常重要的。
你的疑问主要集中在“多个消费者同时消费一条消息，如果消息被确认了，是否会影响其他消费者的接收”这个问题上。

### 发布/订阅模式的工作原理
在RabbitMQ中，发布/订阅模式通常通过`fanout`、`topic`或`direct`类型的交换机实现。当使用这些类型的交换机时，消息会被广播到所有绑定到该交换机的队列。每个队列可以有多个消费者，但关键点在于：
- **每条消息只会进入一个队列**：尽管消息可以通过交换机被路由到多个队列，但是一旦消息到达了一个具体的队列，它就属于那个队列了。
- **队列中的消息可以由多个消费者竞争消费**：如果一个队列有多个消费者，那么这些消费者会竞争地从队列中获取消息。这意味着一条消息只会被其中一个消费者处理。
- 
### 消息确认的作用
消息确认机制（Acknowledgment）确保只有当消息被成功处理后，才会从队列中移除。这对于保证消息不会丢失至关重要。即使在发布/订阅模式下，这一机制仍然适用，因为它保证了消息仅在被实际处理后才被删除。
- **对于单个队列内的多个消费者**：在这种情况下，消息确认机制确保了一条消息只能被一个消费者处理，并且只有当这个消费者确认了消息之后，这条消息才会从队列中移除。这对其他消费者没有影响，因为他们正在尝试从同一个队列中获取不同的消息。
- **对于广播到多个队列的消息**：在真正的发布/订阅场景中（例如使用`fanout`交换机），消息会被复制并发送到所有相关的队列。每个队列都有自己的副本，因此每个队列上的消费者都可以独立地处理它们自己的消息副本。在这个上下文中，一个队列上的消息确认不会影响另一个队列上的消息状态。

### 结论
因此，在发布/订阅模式下，消息确认机制并不会影响其他消费者对相同消息的处理，因为：
- 在单个队列内，消息是被竞争性消费的，只有一个消费者能处理特定的消息。
- 对于广播到多个队列的情况，每个队列都有自己的消息副本，各队列之间的消息处理是完全独立的。
这样做不仅保证了消息能够被可靠地处理，同时也允许系统在需要时扩展为多个消费者以提高吞吐量。